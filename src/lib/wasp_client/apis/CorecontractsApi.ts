/* tslint:disable */
/* eslint-disable */
/**
 * Wasp API
 * REST API for the Wasp node
 *
 * The version of the OpenAPI document: 0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountFoundriesResponse,
  AccountListResponse,
  AccountNFTsResponse,
  AccountNonceResponse,
  AssetsResponse,
  BlobInfoResponse,
  BlobListResponse,
  BlobValueResponse,
  BlockInfoResponse,
  BlockReceiptsResponse,
  ControlAddressesResponse,
  ErrorMessageFormatResponse,
  EventsResponse,
  FoundryOutputResponse,
  GovAllowedStateControllerAddressesResponse,
  GovChainInfoResponse,
  GovChainOwnerResponse,
  NFTDataResponse,
  NativeTokenIDRegistryResponse,
  RequestIDsResponse,
  RequestProcessedResponse,
  RequestReceiptResponse,
  ValidationError,
} from '../models';
import {
    AccountFoundriesResponseFromJSON,
    AccountFoundriesResponseToJSON,
    AccountListResponseFromJSON,
    AccountListResponseToJSON,
    AccountNFTsResponseFromJSON,
    AccountNFTsResponseToJSON,
    AccountNonceResponseFromJSON,
    AccountNonceResponseToJSON,
    AssetsResponseFromJSON,
    AssetsResponseToJSON,
    BlobInfoResponseFromJSON,
    BlobInfoResponseToJSON,
    BlobListResponseFromJSON,
    BlobListResponseToJSON,
    BlobValueResponseFromJSON,
    BlobValueResponseToJSON,
    BlockInfoResponseFromJSON,
    BlockInfoResponseToJSON,
    BlockReceiptsResponseFromJSON,
    BlockReceiptsResponseToJSON,
    ControlAddressesResponseFromJSON,
    ControlAddressesResponseToJSON,
    ErrorMessageFormatResponseFromJSON,
    ErrorMessageFormatResponseToJSON,
    EventsResponseFromJSON,
    EventsResponseToJSON,
    FoundryOutputResponseFromJSON,
    FoundryOutputResponseToJSON,
    GovAllowedStateControllerAddressesResponseFromJSON,
    GovAllowedStateControllerAddressesResponseToJSON,
    GovChainInfoResponseFromJSON,
    GovChainInfoResponseToJSON,
    GovChainOwnerResponseFromJSON,
    GovChainOwnerResponseToJSON,
    NFTDataResponseFromJSON,
    NFTDataResponseToJSON,
    NativeTokenIDRegistryResponseFromJSON,
    NativeTokenIDRegistryResponseToJSON,
    RequestIDsResponseFromJSON,
    RequestIDsResponseToJSON,
    RequestProcessedResponseFromJSON,
    RequestProcessedResponseToJSON,
    RequestReceiptResponseFromJSON,
    RequestReceiptResponseToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface AccountsGetAccountBalanceRequest {
    chainID: string;
    agentID: string;
}

export interface AccountsGetAccountFoundriesRequest {
    chainID: string;
    agentID: string;
}

export interface AccountsGetAccountNFTIDsRequest {
    chainID: string;
    agentID: string;
}

export interface AccountsGetAccountNonceRequest {
    chainID: string;
    agentID: string;
}

export interface AccountsGetAccountsRequest {
    chainID: string;
}

export interface AccountsGetFoundryOutputRequest {
    chainID: string;
    serialNumber: number;
}

export interface AccountsGetNFTDataRequest {
    chainID: string;
    nftID: string;
}

export interface AccountsGetNativeTokenIDRegistryRequest {
    chainID: string;
}

export interface AccountsGetTotalAssetsRequest {
    chainID: string;
}

export interface BlobsGetAllBlobsRequest {
    chainID: string;
}

export interface BlobsGetBlobInfoRequest {
    chainID: string;
    blobHash: string;
}

export interface BlobsGetBlobValueRequest {
    chainID: string;
    blobHash: string;
    fieldKey: string;
}

export interface BlocklogGetBlockInfoRequest {
    chainID: string;
    blockIndex: number;
}

export interface BlocklogGetControlAddressesRequest {
    chainID: string;
}

export interface BlocklogGetEventsOfBlockRequest {
    chainID: string;
    blockIndex: number;
}

export interface BlocklogGetEventsOfContractRequest {
    chainID: string;
    contractHname: string;
}

export interface BlocklogGetEventsOfLatestBlockRequest {
    chainID: string;
}

export interface BlocklogGetEventsOfRequestRequest {
    chainID: string;
    requestID: string;
}

export interface BlocklogGetLatestBlockInfoRequest {
    chainID: string;
}

export interface BlocklogGetRequestIDsForBlockRequest {
    chainID: string;
    blockIndex: number;
}

export interface BlocklogGetRequestIDsForLatestBlockRequest {
    chainID: string;
}

export interface BlocklogGetRequestIsProcessedRequest {
    chainID: string;
    requestID: string;
}

export interface BlocklogGetRequestReceiptRequest {
    chainID: string;
    requestID: string;
}

export interface BlocklogGetRequestReceiptsOfBlockRequest {
    chainID: string;
    blockIndex: number;
}

export interface BlocklogGetRequestReceiptsOfLatestBlockRequest {
    chainID: string;
}

export interface ErrorsGetErrorMessageFormatRequest {
    chainID: string;
    contractHname: string;
    errorID: number;
}

export interface GovernanceGetAllowedStateControllerAddressesRequest {
    chainID: string;
}

export interface GovernanceGetChainInfoRequest {
    chainID: string;
}

export interface GovernanceGetChainOwnerRequest {
    chainID: string;
}

/**
 * 
 */
export class CorecontractsApi extends runtime.BaseAPI {

    /**
     * Get all assets belonging to an account
     */
    async accountsGetAccountBalanceRaw(requestParameters: AccountsGetAccountBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetAccountBalance.');
        }

        if (requestParameters.agentID === null || requestParameters.agentID === undefined) {
            throw new runtime.RequiredError('agentID','Required parameter requestParameters.agentID was null or undefined when calling accountsGetAccountBalance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/account/{agentID}/balance`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"agentID"}}`, encodeURIComponent(String(requestParameters.agentID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsResponseFromJSON(jsonValue));
    }

    /**
     * Get all assets belonging to an account
     */
    async accountsGetAccountBalance(requestParameters: AccountsGetAccountBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetsResponse> {
        const response = await this.accountsGetAccountBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all foundries owned by an account
     */
    async accountsGetAccountFoundriesRaw(requestParameters: AccountsGetAccountFoundriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountFoundriesResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetAccountFoundries.');
        }

        if (requestParameters.agentID === null || requestParameters.agentID === undefined) {
            throw new runtime.RequiredError('agentID','Required parameter requestParameters.agentID was null or undefined when calling accountsGetAccountFoundries.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/account/{agentID}/foundries`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"agentID"}}`, encodeURIComponent(String(requestParameters.agentID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFoundriesResponseFromJSON(jsonValue));
    }

    /**
     * Get all foundries owned by an account
     */
    async accountsGetAccountFoundries(requestParameters: AccountsGetAccountFoundriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountFoundriesResponse> {
        const response = await this.accountsGetAccountFoundriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all NFT ids belonging to an account
     */
    async accountsGetAccountNFTIDsRaw(requestParameters: AccountsGetAccountNFTIDsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountNFTsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetAccountNFTIDs.');
        }

        if (requestParameters.agentID === null || requestParameters.agentID === undefined) {
            throw new runtime.RequiredError('agentID','Required parameter requestParameters.agentID was null or undefined when calling accountsGetAccountNFTIDs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/account/{agentID}/nfts`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"agentID"}}`, encodeURIComponent(String(requestParameters.agentID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountNFTsResponseFromJSON(jsonValue));
    }

    /**
     * Get all NFT ids belonging to an account
     */
    async accountsGetAccountNFTIDs(requestParameters: AccountsGetAccountNFTIDsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountNFTsResponse> {
        const response = await this.accountsGetAccountNFTIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current nonce of an account
     */
    async accountsGetAccountNonceRaw(requestParameters: AccountsGetAccountNonceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountNonceResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetAccountNonce.');
        }

        if (requestParameters.agentID === null || requestParameters.agentID === undefined) {
            throw new runtime.RequiredError('agentID','Required parameter requestParameters.agentID was null or undefined when calling accountsGetAccountNonce.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/account/{agentID}/nonce`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"agentID"}}`, encodeURIComponent(String(requestParameters.agentID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountNonceResponseFromJSON(jsonValue));
    }

    /**
     * Get the current nonce of an account
     */
    async accountsGetAccountNonce(requestParameters: AccountsGetAccountNonceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountNonceResponse> {
        const response = await this.accountsGetAccountNonceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all accounts
     */
    async accountsGetAccountsRaw(requestParameters: AccountsGetAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountListResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetAccounts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountListResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all accounts
     */
    async accountsGetAccounts(requestParameters: AccountsGetAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountListResponse> {
        const response = await this.accountsGetAccountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the foundry output
     */
    async accountsGetFoundryOutputRaw(requestParameters: AccountsGetFoundryOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryOutputResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetFoundryOutput.');
        }

        if (requestParameters.serialNumber === null || requestParameters.serialNumber === undefined) {
            throw new runtime.RequiredError('serialNumber','Required parameter requestParameters.serialNumber was null or undefined when calling accountsGetFoundryOutput.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/foundry_output/{serialNumber}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"serialNumber"}}`, encodeURIComponent(String(requestParameters.serialNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryOutputResponseFromJSON(jsonValue));
    }

    /**
     * Get the foundry output
     */
    async accountsGetFoundryOutput(requestParameters: AccountsGetFoundryOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryOutputResponse> {
        const response = await this.accountsGetFoundryOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the NFT data by an ID
     */
    async accountsGetNFTDataRaw(requestParameters: AccountsGetNFTDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NFTDataResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetNFTData.');
        }

        if (requestParameters.nftID === null || requestParameters.nftID === undefined) {
            throw new runtime.RequiredError('nftID','Required parameter requestParameters.nftID was null or undefined when calling accountsGetNFTData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/nftdata/{nftID}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"nftID"}}`, encodeURIComponent(String(requestParameters.nftID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NFTDataResponseFromJSON(jsonValue));
    }

    /**
     * Get the NFT data by an ID
     */
    async accountsGetNFTData(requestParameters: AccountsGetNFTDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NFTDataResponse> {
        const response = await this.accountsGetNFTDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all registries
     */
    async accountsGetNativeTokenIDRegistryRaw(requestParameters: AccountsGetNativeTokenIDRegistryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NativeTokenIDRegistryResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetNativeTokenIDRegistry.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/token_registry`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NativeTokenIDRegistryResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all registries
     */
    async accountsGetNativeTokenIDRegistry(requestParameters: AccountsGetNativeTokenIDRegistryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NativeTokenIDRegistryResponse> {
        const response = await this.accountsGetNativeTokenIDRegistryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all stored assets
     */
    async accountsGetTotalAssetsRaw(requestParameters: AccountsGetTotalAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling accountsGetTotalAssets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/accounts/total_assets`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsResponseFromJSON(jsonValue));
    }

    /**
     * Get all stored assets
     */
    async accountsGetTotalAssets(requestParameters: AccountsGetTotalAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetsResponse> {
        const response = await this.accountsGetTotalAssetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all stored blobs
     */
    async blobsGetAllBlobsRaw(requestParameters: BlobsGetAllBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlobListResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blobsGetAllBlobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blobs`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlobListResponseFromJSON(jsonValue));
    }

    /**
     * Get all stored blobs
     */
    async blobsGetAllBlobs(requestParameters: BlobsGetAllBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlobListResponse> {
        const response = await this.blobsGetAllBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all fields of a blob
     */
    async blobsGetBlobInfoRaw(requestParameters: BlobsGetBlobInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlobInfoResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blobsGetBlobInfo.');
        }

        if (requestParameters.blobHash === null || requestParameters.blobHash === undefined) {
            throw new runtime.RequiredError('blobHash','Required parameter requestParameters.blobHash was null or undefined when calling blobsGetBlobInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blobs/{blobHash}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blobHash"}}`, encodeURIComponent(String(requestParameters.blobHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlobInfoResponseFromJSON(jsonValue));
    }

    /**
     * Get all fields of a blob
     */
    async blobsGetBlobInfo(requestParameters: BlobsGetBlobInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlobInfoResponse> {
        const response = await this.blobsGetBlobInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the value of the supplied field (key)
     */
    async blobsGetBlobValueRaw(requestParameters: BlobsGetBlobValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlobValueResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blobsGetBlobValue.');
        }

        if (requestParameters.blobHash === null || requestParameters.blobHash === undefined) {
            throw new runtime.RequiredError('blobHash','Required parameter requestParameters.blobHash was null or undefined when calling blobsGetBlobValue.');
        }

        if (requestParameters.fieldKey === null || requestParameters.fieldKey === undefined) {
            throw new runtime.RequiredError('fieldKey','Required parameter requestParameters.fieldKey was null or undefined when calling blobsGetBlobValue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blobs/{blobHash}/data/{fieldKey}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blobHash"}}`, encodeURIComponent(String(requestParameters.blobHash))).replace(`{${"fieldKey"}}`, encodeURIComponent(String(requestParameters.fieldKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlobValueResponseFromJSON(jsonValue));
    }

    /**
     * Get the value of the supplied field (key)
     */
    async blobsGetBlobValue(requestParameters: BlobsGetBlobValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlobValueResponse> {
        const response = await this.blobsGetBlobValueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the block info of a certain block index
     */
    async blocklogGetBlockInfoRaw(requestParameters: BlocklogGetBlockInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockInfoResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetBlockInfo.');
        }

        if (requestParameters.blockIndex === null || requestParameters.blockIndex === undefined) {
            throw new runtime.RequiredError('blockIndex','Required parameter requestParameters.blockIndex was null or undefined when calling blocklogGetBlockInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/{blockIndex}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blockIndex"}}`, encodeURIComponent(String(requestParameters.blockIndex))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockInfoResponseFromJSON(jsonValue));
    }

    /**
     * Get the block info of a certain block index
     */
    async blocklogGetBlockInfo(requestParameters: BlocklogGetBlockInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockInfoResponse> {
        const response = await this.blocklogGetBlockInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the control addresses
     */
    async blocklogGetControlAddressesRaw(requestParameters: BlocklogGetControlAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ControlAddressesResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetControlAddresses.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/controladdresses`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ControlAddressesResponseFromJSON(jsonValue));
    }

    /**
     * Get the control addresses
     */
    async blocklogGetControlAddresses(requestParameters: BlocklogGetControlAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ControlAddressesResponse> {
        const response = await this.blocklogGetControlAddressesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get events of a block
     */
    async blocklogGetEventsOfBlockRaw(requestParameters: BlocklogGetEventsOfBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetEventsOfBlock.');
        }

        if (requestParameters.blockIndex === null || requestParameters.blockIndex === undefined) {
            throw new runtime.RequiredError('blockIndex','Required parameter requestParameters.blockIndex was null or undefined when calling blocklogGetEventsOfBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/events/block/{blockIndex}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blockIndex"}}`, encodeURIComponent(String(requestParameters.blockIndex))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
    }

    /**
     * Get events of a block
     */
    async blocklogGetEventsOfBlock(requestParameters: BlocklogGetEventsOfBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventsResponse> {
        const response = await this.blocklogGetEventsOfBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get events of a contract
     */
    async blocklogGetEventsOfContractRaw(requestParameters: BlocklogGetEventsOfContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetEventsOfContract.');
        }

        if (requestParameters.contractHname === null || requestParameters.contractHname === undefined) {
            throw new runtime.RequiredError('contractHname','Required parameter requestParameters.contractHname was null or undefined when calling blocklogGetEventsOfContract.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/events/contract/{contractHname}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"contractHname"}}`, encodeURIComponent(String(requestParameters.contractHname))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
    }

    /**
     * Get events of a contract
     */
    async blocklogGetEventsOfContract(requestParameters: BlocklogGetEventsOfContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventsResponse> {
        const response = await this.blocklogGetEventsOfContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get events of the latest block
     */
    async blocklogGetEventsOfLatestBlockRaw(requestParameters: BlocklogGetEventsOfLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetEventsOfLatestBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/events/block/latest`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
    }

    /**
     * Get events of the latest block
     */
    async blocklogGetEventsOfLatestBlock(requestParameters: BlocklogGetEventsOfLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventsResponse> {
        const response = await this.blocklogGetEventsOfLatestBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get events of a request
     */
    async blocklogGetEventsOfRequestRaw(requestParameters: BlocklogGetEventsOfRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetEventsOfRequest.');
        }

        if (requestParameters.requestID === null || requestParameters.requestID === undefined) {
            throw new runtime.RequiredError('requestID','Required parameter requestParameters.requestID was null or undefined when calling blocklogGetEventsOfRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/events/request/{requestID}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"requestID"}}`, encodeURIComponent(String(requestParameters.requestID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
    }

    /**
     * Get events of a request
     */
    async blocklogGetEventsOfRequest(requestParameters: BlocklogGetEventsOfRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventsResponse> {
        const response = await this.blocklogGetEventsOfRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the block info of the latest block
     */
    async blocklogGetLatestBlockInfoRaw(requestParameters: BlocklogGetLatestBlockInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockInfoResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetLatestBlockInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/latest`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockInfoResponseFromJSON(jsonValue));
    }

    /**
     * Get the block info of the latest block
     */
    async blocklogGetLatestBlockInfo(requestParameters: BlocklogGetLatestBlockInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockInfoResponse> {
        const response = await this.blocklogGetLatestBlockInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the request ids for a certain block index
     */
    async blocklogGetRequestIDsForBlockRaw(requestParameters: BlocklogGetRequestIDsForBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RequestIDsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestIDsForBlock.');
        }

        if (requestParameters.blockIndex === null || requestParameters.blockIndex === undefined) {
            throw new runtime.RequiredError('blockIndex','Required parameter requestParameters.blockIndex was null or undefined when calling blocklogGetRequestIDsForBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/{blockIndex}/requestids`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blockIndex"}}`, encodeURIComponent(String(requestParameters.blockIndex))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RequestIDsResponseFromJSON(jsonValue));
    }

    /**
     * Get the request ids for a certain block index
     */
    async blocklogGetRequestIDsForBlock(requestParameters: BlocklogGetRequestIDsForBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RequestIDsResponse> {
        const response = await this.blocklogGetRequestIDsForBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the request ids for the latest block
     */
    async blocklogGetRequestIDsForLatestBlockRaw(requestParameters: BlocklogGetRequestIDsForLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RequestIDsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestIDsForLatestBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/latest/requestids`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RequestIDsResponseFromJSON(jsonValue));
    }

    /**
     * Get the request ids for the latest block
     */
    async blocklogGetRequestIDsForLatestBlock(requestParameters: BlocklogGetRequestIDsForLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RequestIDsResponse> {
        const response = await this.blocklogGetRequestIDsForLatestBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the request processing status
     */
    async blocklogGetRequestIsProcessedRaw(requestParameters: BlocklogGetRequestIsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RequestProcessedResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestIsProcessed.');
        }

        if (requestParameters.requestID === null || requestParameters.requestID === undefined) {
            throw new runtime.RequiredError('requestID','Required parameter requestParameters.requestID was null or undefined when calling blocklogGetRequestIsProcessed.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/requests/{requestID}/is_processed`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"requestID"}}`, encodeURIComponent(String(requestParameters.requestID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RequestProcessedResponseFromJSON(jsonValue));
    }

    /**
     * Get the request processing status
     */
    async blocklogGetRequestIsProcessed(requestParameters: BlocklogGetRequestIsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RequestProcessedResponse> {
        const response = await this.blocklogGetRequestIsProcessedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the receipt of a certain request id
     */
    async blocklogGetRequestReceiptRaw(requestParameters: BlocklogGetRequestReceiptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RequestReceiptResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestReceipt.');
        }

        if (requestParameters.requestID === null || requestParameters.requestID === undefined) {
            throw new runtime.RequiredError('requestID','Required parameter requestParameters.requestID was null or undefined when calling blocklogGetRequestReceipt.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/requests/{requestID}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"requestID"}}`, encodeURIComponent(String(requestParameters.requestID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RequestReceiptResponseFromJSON(jsonValue));
    }

    /**
     * Get the receipt of a certain request id
     */
    async blocklogGetRequestReceipt(requestParameters: BlocklogGetRequestReceiptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RequestReceiptResponse> {
        const response = await this.blocklogGetRequestReceiptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all receipts of a certain block
     */
    async blocklogGetRequestReceiptsOfBlockRaw(requestParameters: BlocklogGetRequestReceiptsOfBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockReceiptsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestReceiptsOfBlock.');
        }

        if (requestParameters.blockIndex === null || requestParameters.blockIndex === undefined) {
            throw new runtime.RequiredError('blockIndex','Required parameter requestParameters.blockIndex was null or undefined when calling blocklogGetRequestReceiptsOfBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/{blockIndex}/receipts`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"blockIndex"}}`, encodeURIComponent(String(requestParameters.blockIndex))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockReceiptsResponseFromJSON(jsonValue));
    }

    /**
     * Get all receipts of a certain block
     */
    async blocklogGetRequestReceiptsOfBlock(requestParameters: BlocklogGetRequestReceiptsOfBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockReceiptsResponse> {
        const response = await this.blocklogGetRequestReceiptsOfBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all receipts of the latest block
     */
    async blocklogGetRequestReceiptsOfLatestBlockRaw(requestParameters: BlocklogGetRequestReceiptsOfLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockReceiptsResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling blocklogGetRequestReceiptsOfLatestBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/blocklog/blocks/latest/receipts`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockReceiptsResponseFromJSON(jsonValue));
    }

    /**
     * Get all receipts of the latest block
     */
    async blocklogGetRequestReceiptsOfLatestBlock(requestParameters: BlocklogGetRequestReceiptsOfLatestBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockReceiptsResponse> {
        const response = await this.blocklogGetRequestReceiptsOfLatestBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the error message format of a specific error id
     */
    async errorsGetErrorMessageFormatRaw(requestParameters: ErrorsGetErrorMessageFormatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ErrorMessageFormatResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling errorsGetErrorMessageFormat.');
        }

        if (requestParameters.contractHname === null || requestParameters.contractHname === undefined) {
            throw new runtime.RequiredError('contractHname','Required parameter requestParameters.contractHname was null or undefined when calling errorsGetErrorMessageFormat.');
        }

        if (requestParameters.errorID === null || requestParameters.errorID === undefined) {
            throw new runtime.RequiredError('errorID','Required parameter requestParameters.errorID was null or undefined when calling errorsGetErrorMessageFormat.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/errors/{contractHname}/message/{errorID}`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))).replace(`{${"contractHname"}}`, encodeURIComponent(String(requestParameters.contractHname))).replace(`{${"errorID"}}`, encodeURIComponent(String(requestParameters.errorID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ErrorMessageFormatResponseFromJSON(jsonValue));
    }

    /**
     * Get the error message format of a specific error id
     */
    async errorsGetErrorMessageFormat(requestParameters: ErrorsGetErrorMessageFormatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ErrorMessageFormatResponse> {
        const response = await this.errorsGetErrorMessageFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the allowed state controller addresses
     * Get the allowed state controller addresses
     */
    async governanceGetAllowedStateControllerAddressesRaw(requestParameters: GovernanceGetAllowedStateControllerAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GovAllowedStateControllerAddressesResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling governanceGetAllowedStateControllerAddresses.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/governance/allowedstatecontrollers`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GovAllowedStateControllerAddressesResponseFromJSON(jsonValue));
    }

    /**
     * Returns the allowed state controller addresses
     * Get the allowed state controller addresses
     */
    async governanceGetAllowedStateControllerAddresses(requestParameters: GovernanceGetAllowedStateControllerAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GovAllowedStateControllerAddressesResponse> {
        const response = await this.governanceGetAllowedStateControllerAddressesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are using the common API functions, you most likely rather want to use \'/v1/chains/:chainID\' to get information about a chain.
     * Get the chain info
     */
    async governanceGetChainInfoRaw(requestParameters: GovernanceGetChainInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GovChainInfoResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling governanceGetChainInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/governance/chaininfo`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GovChainInfoResponseFromJSON(jsonValue));
    }

    /**
     * If you are using the common API functions, you most likely rather want to use \'/v1/chains/:chainID\' to get information about a chain.
     * Get the chain info
     */
    async governanceGetChainInfo(requestParameters: GovernanceGetChainInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GovChainInfoResponse> {
        const response = await this.governanceGetChainInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the chain owner
     * Get the chain owner
     */
    async governanceGetChainOwnerRaw(requestParameters: GovernanceGetChainOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GovChainOwnerResponse>> {
        if (requestParameters.chainID === null || requestParameters.chainID === undefined) {
            throw new runtime.RequiredError('chainID','Required parameter requestParameters.chainID was null or undefined when calling governanceGetChainOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/chains/{chainID}/core/governance/chainowner`.replace(`{${"chainID"}}`, encodeURIComponent(String(requestParameters.chainID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GovChainOwnerResponseFromJSON(jsonValue));
    }

    /**
     * Returns the chain owner
     * Get the chain owner
     */
    async governanceGetChainOwner(requestParameters: GovernanceGetChainOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GovChainOwnerResponse> {
        const response = await this.governanceGetChainOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
