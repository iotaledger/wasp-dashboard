export * from '../models/AccountFoundriesResponse';
export * from '../models/AccountListResponse';
export * from '../models/AccountNFTsResponse';
export * from '../models/AccountNonceResponse';
export * from '../models/AddUserRequest';
export * from '../models/AliasOutputMetricItem';
export * from '../models/Assets';
export * from '../models/AssetsResponse';
export * from '../models/AuthInfoModel';
export * from '../models/BaseToken';
export * from '../models/Blob';
export * from '../models/BlobInfoResponse';
export * from '../models/BlobListResponse';
export * from '../models/BlobValueResponse';
export * from '../models/BlockInfoResponse';
export * from '../models/BurnRecord';
export * from '../models/CallTarget';
export * from '../models/ChainInfoResponse';
export * from '../models/ChainMessageMetrics';
export * from '../models/ChainRecord';
export * from '../models/CommitteeInfoResponse';
export * from '../models/CommitteeNode';
export * from '../models/ConsensusPipeMetrics';
export * from '../models/ConsensusWorkflowMetrics';
export * from '../models/ContractCallViewRequest';
export * from '../models/ContractInfoResponse';
export * from '../models/ControlAddressesResponse';
export * from '../models/DKSharesInfo';
export * from '../models/DKSharesPostRequest';
export * from '../models/ErrorMessageFormatResponse';
export * from '../models/EstimateGasRequestOffledger';
export * from '../models/EstimateGasRequestOnledger';
export * from '../models/EventJSON';
export * from '../models/EventsResponse';
export * from '../models/FeePolicy';
export * from '../models/FoundryOutputResponse';
export * from '../models/GovAllowedStateControllerAddressesResponse';
export * from '../models/GovChainInfoResponse';
export * from '../models/GovChainOwnerResponse';
export * from '../models/GovPublicChainMetadata';
export * from '../models/InOutput';
export * from '../models/InOutputMetricItem';
export * from '../models/InStateOutput';
export * from '../models/InStateOutputMetricItem';
export * from '../models/InfoResponse';
export * from '../models/InterfaceMetricItem';
export * from '../models/Item';
export * from '../models/JSONDict';
export * from '../models/L1Params';
export * from '../models/Limits';
export * from '../models/LoginRequest';
export * from '../models/LoginResponse';
export * from '../models/MilestoneInfo';
export * from '../models/MilestoneMetricItem';
export * from '../models/NFTDataResponse';
export * from '../models/NativeToken';
export * from '../models/NativeTokenIDRegistryResponse';
export * from '../models/NodeMessageMetrics';
export * from '../models/NodeOwnerCertificateResponse';
export * from '../models/OffLedgerRequest';
export * from '../models/OnLedgerRequest';
export * from '../models/OnLedgerRequestMetricItem';
export * from '../models/Output';
export * from '../models/OutputID';
export * from '../models/PeeringNodeIdentityResponse';
export * from '../models/PeeringNodeStatusResponse';
export * from '../models/PeeringTrustRequest';
export * from '../models/ProtocolParameters';
export * from '../models/PublicChainMetadata';
export * from '../models/PublisherStateTransactionItem';
export * from '../models/Ratio32';
export * from '../models/ReceiptResponse';
export * from '../models/RentStructure';
export * from '../models/RequestDetail';
export * from '../models/RequestIDsResponse';
export * from '../models/RequestProcessedResponse';
export * from '../models/StateResponse';
export * from '../models/StateTransaction';
export * from '../models/Transaction';
export * from '../models/TransactionIDMetricItem';
export * from '../models/TransactionMetricItem';
export * from '../models/TxInclusionStateMsg';
export * from '../models/TxInclusionStateMsgMetricItem';
export * from '../models/UTXOInputMetricItem';
export * from '../models/UnresolvedVMErrorJSON';
export * from '../models/UpdateUserPasswordRequest';
export * from '../models/UpdateUserPermissionsRequest';
export * from '../models/User';
export * from '../models/ValidationError';
export * from '../models/VersionResponse';

import { AccountFoundriesResponse } from '../models/AccountFoundriesResponse';
import { AccountListResponse } from '../models/AccountListResponse';
import { AccountNFTsResponse } from '../models/AccountNFTsResponse';
import { AccountNonceResponse } from '../models/AccountNonceResponse';
import { AddUserRequest } from '../models/AddUserRequest';
import { AliasOutputMetricItem } from '../models/AliasOutputMetricItem';
import { Assets } from '../models/Assets';
import { AssetsResponse } from '../models/AssetsResponse';
import { AuthInfoModel } from '../models/AuthInfoModel';
import { BaseToken } from '../models/BaseToken';
import { Blob } from '../models/Blob';
import { BlobInfoResponse } from '../models/BlobInfoResponse';
import { BlobListResponse } from '../models/BlobListResponse';
import { BlobValueResponse } from '../models/BlobValueResponse';
import { BlockInfoResponse } from '../models/BlockInfoResponse';
import { BurnRecord } from '../models/BurnRecord';
import { CallTarget } from '../models/CallTarget';
import { ChainInfoResponse } from '../models/ChainInfoResponse';
import { ChainMessageMetrics } from '../models/ChainMessageMetrics';
import { ChainRecord } from '../models/ChainRecord';
import { CommitteeInfoResponse } from '../models/CommitteeInfoResponse';
import { CommitteeNode } from '../models/CommitteeNode';
import { ConsensusPipeMetrics } from '../models/ConsensusPipeMetrics';
import { ConsensusWorkflowMetrics } from '../models/ConsensusWorkflowMetrics';
import { ContractCallViewRequest } from '../models/ContractCallViewRequest';
import { ContractInfoResponse } from '../models/ContractInfoResponse';
import { ControlAddressesResponse } from '../models/ControlAddressesResponse';
import { DKSharesInfo } from '../models/DKSharesInfo';
import { DKSharesPostRequest } from '../models/DKSharesPostRequest';
import { ErrorMessageFormatResponse } from '../models/ErrorMessageFormatResponse';
import { EstimateGasRequestOffledger } from '../models/EstimateGasRequestOffledger';
import { EstimateGasRequestOnledger } from '../models/EstimateGasRequestOnledger';
import { EventJSON } from '../models/EventJSON';
import { EventsResponse } from '../models/EventsResponse';
import { FeePolicy } from '../models/FeePolicy';
import { FoundryOutputResponse } from '../models/FoundryOutputResponse';
import { GovAllowedStateControllerAddressesResponse } from '../models/GovAllowedStateControllerAddressesResponse';
import { GovChainInfoResponse } from '../models/GovChainInfoResponse';
import { GovChainOwnerResponse } from '../models/GovChainOwnerResponse';
import { GovPublicChainMetadata } from '../models/GovPublicChainMetadata';
import { InOutput } from '../models/InOutput';
import { InOutputMetricItem } from '../models/InOutputMetricItem';
import { InStateOutput } from '../models/InStateOutput';
import { InStateOutputMetricItem } from '../models/InStateOutputMetricItem';
import { InfoResponse } from '../models/InfoResponse';
import { InterfaceMetricItem } from '../models/InterfaceMetricItem';
import { Item } from '../models/Item';
import { JSONDict } from '../models/JSONDict';
import { L1Params } from '../models/L1Params';
import { Limits } from '../models/Limits';
import { LoginRequest } from '../models/LoginRequest';
import { LoginResponse } from '../models/LoginResponse';
import { MilestoneInfo } from '../models/MilestoneInfo';
import { MilestoneMetricItem } from '../models/MilestoneMetricItem';
import { NFTDataResponse } from '../models/NFTDataResponse';
import { NativeToken } from '../models/NativeToken';
import { NativeTokenIDRegistryResponse } from '../models/NativeTokenIDRegistryResponse';
import { NodeMessageMetrics } from '../models/NodeMessageMetrics';
import { NodeOwnerCertificateResponse } from '../models/NodeOwnerCertificateResponse';
import { OffLedgerRequest } from '../models/OffLedgerRequest';
import { OnLedgerRequest } from '../models/OnLedgerRequest';
import { OnLedgerRequestMetricItem } from '../models/OnLedgerRequestMetricItem';
import { Output } from '../models/Output';
import { OutputID } from '../models/OutputID';
import { PeeringNodeIdentityResponse } from '../models/PeeringNodeIdentityResponse';
import { PeeringNodeStatusResponse } from '../models/PeeringNodeStatusResponse';
import { PeeringTrustRequest } from '../models/PeeringTrustRequest';
import { ProtocolParameters } from '../models/ProtocolParameters';
import { PublicChainMetadata } from '../models/PublicChainMetadata';
import { PublisherStateTransactionItem } from '../models/PublisherStateTransactionItem';
import { Ratio32 } from '../models/Ratio32';
import { ReceiptResponse } from '../models/ReceiptResponse';
import { RentStructure } from '../models/RentStructure';
import { RequestDetail } from '../models/RequestDetail';
import { RequestIDsResponse } from '../models/RequestIDsResponse';
import { RequestProcessedResponse } from '../models/RequestProcessedResponse';
import { StateResponse } from '../models/StateResponse';
import { StateTransaction } from '../models/StateTransaction';
import { Transaction } from '../models/Transaction';
import { TransactionIDMetricItem } from '../models/TransactionIDMetricItem';
import { TransactionMetricItem } from '../models/TransactionMetricItem';
import { TxInclusionStateMsg } from '../models/TxInclusionStateMsg';
import { TxInclusionStateMsgMetricItem } from '../models/TxInclusionStateMsgMetricItem';
import { UTXOInputMetricItem } from '../models/UTXOInputMetricItem';
import { UnresolvedVMErrorJSON } from '../models/UnresolvedVMErrorJSON';
import { UpdateUserPasswordRequest } from '../models/UpdateUserPasswordRequest';
import { UpdateUserPermissionsRequest } from '../models/UpdateUserPermissionsRequest';
import { User } from '../models/User';
import { ValidationError } from '../models/ValidationError';
import { VersionResponse } from '../models/VersionResponse';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

const supportedMediaTypes: { [mediaType: string]: number } = {
  "application/json": Infinity,
  "application/octet-stream": 0,
  "application/x-www-form-urlencoded": 0
}


let enumsMap: Set<string> = new Set<string>([
]);

let typeMap: {[index: string]: any} = {
    "AccountFoundriesResponse": AccountFoundriesResponse,
    "AccountListResponse": AccountListResponse,
    "AccountNFTsResponse": AccountNFTsResponse,
    "AccountNonceResponse": AccountNonceResponse,
    "AddUserRequest": AddUserRequest,
    "AliasOutputMetricItem": AliasOutputMetricItem,
    "Assets": Assets,
    "AssetsResponse": AssetsResponse,
    "AuthInfoModel": AuthInfoModel,
    "BaseToken": BaseToken,
    "Blob": Blob,
    "BlobInfoResponse": BlobInfoResponse,
    "BlobListResponse": BlobListResponse,
    "BlobValueResponse": BlobValueResponse,
    "BlockInfoResponse": BlockInfoResponse,
    "BurnRecord": BurnRecord,
    "CallTarget": CallTarget,
    "ChainInfoResponse": ChainInfoResponse,
    "ChainMessageMetrics": ChainMessageMetrics,
    "ChainRecord": ChainRecord,
    "CommitteeInfoResponse": CommitteeInfoResponse,
    "CommitteeNode": CommitteeNode,
    "ConsensusPipeMetrics": ConsensusPipeMetrics,
    "ConsensusWorkflowMetrics": ConsensusWorkflowMetrics,
    "ContractCallViewRequest": ContractCallViewRequest,
    "ContractInfoResponse": ContractInfoResponse,
    "ControlAddressesResponse": ControlAddressesResponse,
    "DKSharesInfo": DKSharesInfo,
    "DKSharesPostRequest": DKSharesPostRequest,
    "ErrorMessageFormatResponse": ErrorMessageFormatResponse,
    "EstimateGasRequestOffledger": EstimateGasRequestOffledger,
    "EstimateGasRequestOnledger": EstimateGasRequestOnledger,
    "EventJSON": EventJSON,
    "EventsResponse": EventsResponse,
    "FeePolicy": FeePolicy,
    "FoundryOutputResponse": FoundryOutputResponse,
    "GovAllowedStateControllerAddressesResponse": GovAllowedStateControllerAddressesResponse,
    "GovChainInfoResponse": GovChainInfoResponse,
    "GovChainOwnerResponse": GovChainOwnerResponse,
    "GovPublicChainMetadata": GovPublicChainMetadata,
    "InOutput": InOutput,
    "InOutputMetricItem": InOutputMetricItem,
    "InStateOutput": InStateOutput,
    "InStateOutputMetricItem": InStateOutputMetricItem,
    "InfoResponse": InfoResponse,
    "InterfaceMetricItem": InterfaceMetricItem,
    "Item": Item,
    "JSONDict": JSONDict,
    "L1Params": L1Params,
    "Limits": Limits,
    "LoginRequest": LoginRequest,
    "LoginResponse": LoginResponse,
    "MilestoneInfo": MilestoneInfo,
    "MilestoneMetricItem": MilestoneMetricItem,
    "NFTDataResponse": NFTDataResponse,
    "NativeToken": NativeToken,
    "NativeTokenIDRegistryResponse": NativeTokenIDRegistryResponse,
    "NodeMessageMetrics": NodeMessageMetrics,
    "NodeOwnerCertificateResponse": NodeOwnerCertificateResponse,
    "OffLedgerRequest": OffLedgerRequest,
    "OnLedgerRequest": OnLedgerRequest,
    "OnLedgerRequestMetricItem": OnLedgerRequestMetricItem,
    "Output": Output,
    "OutputID": OutputID,
    "PeeringNodeIdentityResponse": PeeringNodeIdentityResponse,
    "PeeringNodeStatusResponse": PeeringNodeStatusResponse,
    "PeeringTrustRequest": PeeringTrustRequest,
    "ProtocolParameters": ProtocolParameters,
    "PublicChainMetadata": PublicChainMetadata,
    "PublisherStateTransactionItem": PublisherStateTransactionItem,
    "Ratio32": Ratio32,
    "ReceiptResponse": ReceiptResponse,
    "RentStructure": RentStructure,
    "RequestDetail": RequestDetail,
    "RequestIDsResponse": RequestIDsResponse,
    "RequestProcessedResponse": RequestProcessedResponse,
    "StateResponse": StateResponse,
    "StateTransaction": StateTransaction,
    "Transaction": Transaction,
    "TransactionIDMetricItem": TransactionIDMetricItem,
    "TransactionMetricItem": TransactionMetricItem,
    "TxInclusionStateMsg": TxInclusionStateMsg,
    "TxInclusionStateMsgMetricItem": TxInclusionStateMsgMetricItem,
    "UTXOInputMetricItem": UTXOInputMetricItem,
    "UnresolvedVMErrorJSON": UnresolvedVMErrorJSON,
    "UpdateUserPasswordRequest": UpdateUserPasswordRequest,
    "UpdateUserPermissionsRequest": UpdateUserPermissionsRequest,
    "User": User,
    "ValidationError": ValidationError,
    "VersionResponse": VersionResponse,
}

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if(typeMap[discriminatorType]){
                        return discriminatorType; // use the type given in the discriminator
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
                if (value !== undefined) {
                    instance[attributeType.name] = value;
                }
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (!mediaTypes) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
        let selectedMediaType: string | undefined = undefined;
        let selectedRank: number = -Infinity;
        for (const mediaType of normalMediaTypes) {
            if (supportedMediaTypes[mediaType!] > selectedRank) {
                selectedMediaType = mediaType;
                selectedRank = supportedMediaTypes[mediaType!];
            }
        }

        if (selectedMediaType === undefined) {
            throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
        }

        return selectedMediaType!;
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (mediaType === "text/plain") {
            return String(data);
        }

        if (mediaType === "application/json") {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (mediaType === "text/plain") {
            return rawData;
        }

        if (mediaType === "application/json") {
            return JSON.parse(rawData);
        }

        if (mediaType === "text/html") {
            return rawData;
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
